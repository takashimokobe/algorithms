Project 4
Team Members:
Derek Lam
Dhruv Singal
Robert Hensley
Taka Shimokobe
Expected Data Structures
We hypothesized that the source code uses a stack implementation, where the stack’s elements are called arcs. Each arc can be one of two things, another stack, or a pair of line numbers sourced from the compiled Python code. The pair of line numbers is in the format of (previous, after), where previous is executed immediately prior after. Because an interpreter can go in multiple directions, for instance during a conditional if/else statement, an arc can itself be a stack. This would essentially be a tree structure of stacks.

A trace function tells the program when the end of an arc has been reached. Once this has occurred, the program removes the empty arc from the stack and move on to the next arc in the stack. Once a stack is empty, the arc that the stack was a part of is removed from the upper level stack. The coverage is essentially a depth first exploration of a tree made up of stacks and arcs pointing to lines of code.

Initial Code Examination
When opening the source code file, we are greeted with an organized file system and docs folder with various txt and rst files. There is a helpful README file in there that gives a brief explanation of what coverage does as well as documentation links and version history. The coverage folder holds all the main files that control coverage.py and store data, and the tests file holds coverage.py’s tests. Tests contains the three largest files in the source code, from 1304 to 1792 lines. From coverage, the first file we analyzed was data.py, which stored coverage.py’s data structures. A doc-string above gives a forty line summary of the file as well as a commented section discussing how the data structures are stored in dictionaries. Next, we looked at summary.py which stored a coverage report in an outfile. The code was well spaced and commented, so it was easy to break down each part. Backward.py, which is used for backwards compatibility for older versions of python, has comments that state the intricacies of older languages. Even a small misc.py for miscellaneous functions contains numerous comments. Lastly, we analyzed the bytecode.py file, which according to the helpful comments has one class that uses a stack to encode ‘code objects’ using a stack. The two tests we analyzed were test_data.py and test_summary.py The test_data.py file is nearly the same length as the file it is testing. Each test is subdivided into test classes and their respective test definition with many cases. Test_summary.py had detailed representations of terminal outputs in the comments that were helpful in seeing desired outcomes. As a whole, comments in the test and coverage files are as important as the code itself to easily navigate/understand the code.

Detailed Code Examination
The data.py file of the “coverage” directory within the source file seemed to have the most sufficient information regarding our initial speculations about arcs and stacks being the primary data structures required for a functioning coverage tester. Its purpose is to read, collect, and write coverage data into files. The primary data structure that we found related to said speculations was the “arc”. From the file, each arc is defined as a tuple of 2 integers, representing the starting and ending line numbers, respectively, of a certain branch. Essentially, as the trace function is being used, a list of arcs for each file of the coverage call (we had figured out that multiple files could have their coverage checked in one call, either due to explicitly adding more arguments to the “coverage run” command or one file importing modules that didn’t belong to the built-in python libraries,) was created. They were promptly stored in a dictionary with the filename being the key. Arc data could be added through an argument for an add_arcs function. The arc dictionary is used in conjunction with lines executed outside of arcs in order to collect all lines that were executed. Thus, our initial speculations about stacks were most likely wrong. They were just lists of arcs that were executed. The branches that make up the arcs refer to events such as function calls, in which the starting line is the function call and the end line is the function itself. Other examples include if-else branches, loops, etc. The CoverageDataFiles class manages the use of coverage data files. It consists of a “warn” and a “debug”. It is able to warn us if we are doing something wrong. Debug is a “DebugControl” object that is used to write a debug message. There are functions to erase, read, write, combine, debug, and format coverage files.

Summary
The code was relatively readable. While it was clear what each function should be able to do, going through the code we came across built in methods that we haven’t been exposed to. The comments helped a lot in understanding how these methods worked in coverage. For each method, the comments would explain what each object in the function was, as well as how it was used to complete its goal.

The comments in coverage.py differed from our code in that there were detailed comments within definitions, not just at the top of headers. This makes it easy to understand what a function is doing when it is executed. In general, the code was more complex due to the variety of classes and methods.

Testing was clearly an important part of the source code, as it made up a majority of the files. With so many different versions of Python to account for and the fact that one small change can affect another portion of the source code, it is crucial to test every detail of the code. Because of this, maintaining the code must be a tedious task, but it’s mitigated with sufficient tests.